<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="The Redefine Team">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2025/03/18/java语言/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:type" content="article">
<meta property="og:title" content="Java语言">
<meta property="og:url" content="http://example.com/2025/03/18/Java%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/images/redefine-og.webp">
<meta property="article:published_time" content="2025-03-18T12:48:18.000Z">
<meta property="article:modified_time" content="2025-03-18T12:49:23.758Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/redefine-og.webp">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/redefine-favicon.svg">
    <!--- Page Info-->
    
    <title>
        
            Java语言 | Theme Redefine
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"example.com","root":"/","language":"en"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":true,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"Theme Redefine","subtitle":{"text":[],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/8/17 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 7.3.0"></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Theme Redefine
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">2</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			<div class="w-full flex items-center pt-6 justify-start">
				<h1 class="article-title-regular text-second-text-color tracking-tight text-4xl md:text-6xl font-semibold px-2 sm:px-6 md:px-8 py-3">Java语言</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/images/redefine-avatar.svg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">The Redefine Team</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv1</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-03-18 20:48:18</span>
        <span class="mobile">2025-03-18 20:48:18</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-03-18 20:49:23</span>
            <span class="mobile">2025-03-18 20:49:23</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h1 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">步骤一：导包**</span><br><span class="line">**import   Java.util.Scanner;**     导包的动作必须出现在类定义的上边</span><br><span class="line">**步骤二：创建对象**</span><br><span class="line">**Scanner**  sc  **= new  Scanner(System.in);**  //sc是变量名</span><br><span class="line">**步骤三：接收数据**</span><br><span class="line">**int** i **=sc.nextInt( );**     //i 是变量名</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：键盘录入多个变量不需要再次进行步骤一和步骤二</p>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>符号         作用                          说明                                                          例</p>
<p><strong>&amp;</strong>               逻辑<strong>与（且）</strong>        并且，两边都为真，结果才是真            true &amp; true     &#x2F;&#x2F;true</p>
<p><strong>|</strong>               逻辑<strong>或</strong>                    或者，两边都为假，结果才是假            false | false   &#x2F;&#x2F;false</p>
<p><strong>^</strong>               逻辑<strong>异或</strong>                 相同为false，不同为true                      true  ^  true    &#x2F;&#x2F;false</p>
<p><strong>！</strong>             逻辑<strong>非</strong>                     取反                                                         !true                &#x2F;&#x2F;false</p>
<h4 id="短路逻辑运算符"><a href="#短路逻辑运算符" class="headerlink" title="短路逻辑运算符"></a>短路逻辑运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.&amp;&amp;</span><br><span class="line">//运行结果跟单个&amp;是一样的</span><br><span class="line">//表示两边都为真，结果才是真</span><br><span class="line">2.||</span><br><span class="line">//运行结果跟单个|是一样的</span><br><span class="line">//表示两边都为假，结果才是假</span><br><span class="line">3.短路逻辑运算符具有短路效果</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;简单理解：<strong>当左边的表达式能确定最终结果，那么右边就不会参与运行了</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a =10;</span><br><span class="line">int b =10;</span><br><span class="line">boolean result = ++a &lt;5 &amp;&amp; ++b &lt;5;</span><br><span class="line">system.out.println(result);        //false</span><br><span class="line">system.out.println(a);            //11</span><br><span class="line">system.out.println(b);           //10</span><br></pre></td></tr></table></figure>

<p><em><strong>注意事项：</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;|，无论左边true false，右边都要执行</span><br><span class="line">&amp;&amp;||，如果左边能确定整个表达式结果，右边不执行</span><br><span class="line">&amp;&amp;：左边为false，右边不管真假，整个表达式结果一定是false</span><br><span class="line">||：左边为true，右边不管真假，整个表达式结果一定是true</span><br></pre></td></tr></table></figure>

<h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：关系表达式？表达式1：表达式2；//整个三元运算符的结果必须要被使用</span><br><span class="line">示例：</span><br><span class="line">**a&gt;b ? a:b**           //若a&gt;b成立，则三元运算符的结果为a，若不成立，则结果为b</span><br></pre></td></tr></table></figure>

<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table>
<thead>
<tr>
<th align="left">优先级</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td>.  （）{}</td>
</tr>
<tr>
<td align="left">2</td>
<td>！—     ++     –</td>
</tr>
<tr>
<td align="left">3</td>
<td>*    &#x2F;    %</td>
</tr>
<tr>
<td align="left">4</td>
<td>+        -</td>
</tr>
<tr>
<td align="left">5</td>
<td>&lt;&lt;    &gt;&gt;      &gt;&gt;&gt;</td>
</tr>
<tr>
<td align="left">6</td>
<td>&lt;   &lt;&#x3D;  &gt;   &gt;&#x3D;  instanceof</td>
</tr>
<tr>
<td align="left">7</td>
<td>&#x3D;&#x3D;   !&#x3D;</td>
</tr>
<tr>
<td align="left">8</td>
<td>&amp;</td>
</tr>
<tr>
<td align="left">9</td>
<td>^</td>
</tr>
<tr>
<td align="left">10</td>
<td>|</td>
</tr>
<tr>
<td align="left">11</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td align="left">12</td>
<td>||</td>
</tr>
<tr>
<td align="left">13</td>
<td>?:</td>
</tr>
<tr>
<td align="left">14</td>
<td>&#x3D;  +&#x3D; -&#x3D;  *&#x3D;  &#x2F;&#x3D;  %&#x3D;  &amp;&#x3D;</td>
</tr>
</tbody></table>
<h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认从上至下</span><br></pre></td></tr></table></figure>

<h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">if （关系表达式）&#123;</span><br><span class="line">    语句体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行流程：</span><br><span class="line">|.   首先计算关系表达式的值</span><br><span class="line">||.如果关系表达式的值为true就执行语句体</span><br><span class="line">|||.如果关系表达式的值为false就不执行语句体</span><br><span class="line">|V. 继续执行后面的语句体</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if 的注意点：</span><br><span class="line">1.在语句体中，如果只有一句代码，大括号可以省略不写</span><br><span class="line">2.如果对一个布尔类型的变量进行判断，不要用==号，直接把变量写在小括号即可</span><br></pre></td></tr></table></figure>

<p><strong>if 语句第二种格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if （关系表达式）&#123;</span><br><span class="line">     语句体1；</span><br><span class="line">&#125;else &#123;</span><br><span class="line">     语句体2；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>if语句第三种格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if （关系表达式）&#123;</span><br><span class="line">     语句体1；</span><br><span class="line">&#125;else  if &#123;</span><br><span class="line">     语句体2；</span><br><span class="line">&#125;</span><br><span class="line">……else&#123;</span><br><span class="line">     语句体n+1；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch（表达式）&#123;                           执行流程：</span><br><span class="line">case值1：                              1.首先计算表达式的值</span><br><span class="line">        语句体1；                       2.依次和case值比较，如果有对应的值，就会执行相应的语句，</span><br><span class="line">        break；                                      在执行的过程中，遇到break就会结束</span><br><span class="line">case值2：                              3.如果所有的case后面的值和表达式的值都不匹配，就会执行 default里面的语句体，</span><br><span class="line">        语句体2；                                       然后结束整个switch语句</span><br><span class="line">        break；</span><br><span class="line">     …</span><br><span class="line">default：</span><br><span class="line">       语句体n+1；</span><br><span class="line">       break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>格式说明：</p>
<p><strong>表达式</strong>：取值为<strong>byte、short、int、char</strong>。jdk5以后可以是枚举，jdk7以后可以是<strong>string</strong>。</p>
<p>case：后面跟的是要和表达式进行比较的值</p>
<p><strong>case后面的值只能是字面量，不能是变量，case给出的值不允许重复</strong></p>
<p><strong><u>case穿透</u></strong>：就是语句体中没有写break导致</p>
<p>如果没有发现break，程序会继续执行下一个case语句体，直到遇到break或者右大括号为止</p>
<h4 id="switch和if第三种格式各自使用的场景"><a href="#switch和if第三种格式各自使用的场景" class="headerlink" title="switch和if第三种格式各自使用的场景"></a><strong>switch和if第三种格式各自使用的场景</strong></h4><p>if的第三种格式：一般用于对范围的判断</p>
<p>switch：把有限个数一一列举 出来，让我们任选其一</p>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p><strong>格式</strong>：</p>
<p>for（初始化语句；条件判断语句；条件控制语句）{</p>
<p>​    循环体语句；</p>
<p>}</p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p><strong>格式</strong>：</p>
<p>初始化语句；</p>
<p>while（条件判断语句）{</p>
<p>   循环体语句；</p>
<p>   条件控制语句；</p>
<p>}</p>
<h4 id="for和while的区别"><a href="#for和while的区别" class="headerlink" title="for和while的区别"></a>for和while的区别</h4><p>for循环中：知道循环次数或循环范围</p>
<p>while循环：不知道循环的次数和范围，只知道循环的结束条件</p>
<h4 id="跳转控制语句"><a href="#跳转控制语句" class="headerlink" title="跳转控制语句"></a>跳转控制语句</h4><p>1.跳过某一次循环</p>
<p><strong>for(   ){</strong></p>
<p><strong>&#x2F;&#x2F;条件判断</strong></p>
<p><strong>if（）{</strong></p>
<p><strong>continue；  &#x2F;&#x2F;结束本次循环</strong></p>
<p>  <strong>}</strong></p>
<p><strong>}</strong></p>
<p>2.结束整个循环</p>
<p><strong>for(   ){</strong></p>
<p><strong>&#x2F;&#x2F;条件判断</strong></p>
<p><strong>if（）{</strong></p>
<p><strong>break；  &#x2F;&#x2F;结束整个循环</strong></p>
<p>  <strong>}</strong></p>
<p><strong>}</strong></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组：一种容器，可以用来存储同种数据类型的多个值</p>
<p>数组容器在存储数据的时候，需要考虑隐式转换</p>
<p>建议：<strong>容器的类型，和存储的数据类型保持一致</strong></p>
<h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><p>格式一：数据类型 []  array         范例：int  []  array</p>
<p>格式二：数据类型  array[]       范例：int  array []  </p>
<h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><p>初始化:就是在内存中，为数组容器开辟空间，并将数据存入容器中的过程</p>
<h4 id="静态初始化"><a href="#静态初始化" class="headerlink" title="静态初始化"></a>静态初始化</h4><p><strong>完整格式：数据类型[]数组名&#x3D;new 数据类型[]{元素1，元素2，元素3…}</strong></p>
<p><strong>范例：int []array&#x3D;new int []{11，22，33}</strong></p>
<p><strong>简化格式：数据类型[]数组名&#x3D;{元素1，元素2，元素3…}</strong></p>
<h4 id="动态初始化"><a href="#动态初始化" class="headerlink" title="动态初始化"></a>动态初始化</h4><p>动态初始化：初始化<strong>只指定数组长度</strong>，<strong>由系统为数组分配初始值</strong></p>
<p><strong>格式：数据类型 [] 数组名 &#x3D; new 数据类型 [数组长度]</strong></p>
<p>&#x2F;&#x2F;数组默认初始化值的规律</p>
<p>整数类型：默认初始化值0</p>
<p>小数类型：默认初始化值0.0</p>
<p>布尔类型：默认初始化值false</p>
<p>字符类型：默认初始化值’&#x2F;u0000’ 空格</p>
<p>引用数据类型：默认初始化值null</p>
<h4 id="动态与静态初始化的区别"><a href="#动态与静态初始化的区别" class="headerlink" title="动态与静态初始化的区别"></a>动态与静态初始化的区别</h4><p>动态初始化：只确定元素个数，不确定具体数值，由系统给出默认初始化值</p>
<p>静态初始化：手动指定数组元素，系统会根据元素个数，计算数组长度</p>
<h3 id="数组的地址值"><a href="#数组的地址值" class="headerlink" title="数组的地址值"></a>数组的地址值</h3><p>地址值    范例：[D@776ec8df</p>
<p><strong>[  ：表示当前是一个数组</strong></p>
<p><strong>D：表示当前数组里面的元素都是double类型的</strong></p>
<p><strong>@：表示一个间隔符号（固定格式）</strong></p>
<p><strong>776ec8df：数组真正的地址值（十六进制）</strong></p>
<h3 id="数组元素访问"><a href="#数组元素访问" class="headerlink" title="数组元素访问"></a>数组元素访问</h3><p>格式：<strong>数组名[索引]</strong>；</p>
<p>索引：叫做下标，角标</p>
<p>索引的特点：<strong>从0开始，逐个+1增长，连续不间断</strong></p>
<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><p>数组遍历：<strong>将数组中所有的内容取出来</strong>，取出来以后可以（打印，求和，判断…）</p>
<p>注意：遍历是指取出数据的过程</p>
<p>在Java当中，关于数组的一个长度属性，length</p>
<p><strong>调用方式：数组名.length</strong></p>
<p>for(int i&#x3D;0,<strong>i&lt;arr.length</strong>;i++){</p>
<p>​     system.out.println(arr[i]);</p>
<p>}</p>
<h3 id="数组的内存图"><a href="#数组的内存图" class="headerlink" title="数组的内存图"></a>数组的内存图</h3><p>栈内存：方法运行时使用的内存，比如main方法运行，进入方法栈中执行</p>
<p>堆内存：存储对象或数组，new来创建的，都存储在堆内存</p>
<p><img src="D:\腾讯电脑管家截图文件\微信图片_20250307191647.png"></p>
<p><strong>两个数组指向同一个空间的内存图</strong></p>
<p><img src="D:\腾讯电脑管家截图文件\微信图片_20250307192602.png"></p>
<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><p>当我们需要把数据分组管理的时候，就需要用到二维数组</p>
<h3 id="二维数组的初始化"><a href="#二维数组的初始化" class="headerlink" title="二维数组的初始化"></a>二维数组的初始化</h3><h4 id="静态初始化-1"><a href="#静态初始化-1" class="headerlink" title="静态初始化"></a>静态初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：数据类型 [] [] 数组名=new  数据类型 [] []&#123;&#123;元素1，元素2&#125;，&#123;元素1，元素2&#125;&#125; </span><br><span class="line">范例：int [] []arr=new int [] [] &#123;&#123;11，22&#125;，&#123;33，44&#125;&#125; </span><br></pre></td></tr></table></figure>

<h4 id="动态初始化-1"><a href="#动态初始化-1" class="headerlink" title="动态初始化"></a>动态初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：数据类型[] [] 数组名=new 数据类型[m] [n]</span><br><span class="line">m表示这个二维数组可以存放多少个一维数组</span><br><span class="line">n表示每一个一维数组，可以存放多少个元素</span><br></pre></td></tr></table></figure>

<h3 id="二维数组的元素访问"><a href="#二维数组的元素访问" class="headerlink" title="二维数组的元素访问"></a>二维数组的元素访问</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr[i] [j]</span><br><span class="line">arr:二维数组</span><br><span class="line">i：二维数组的索引，获取出来的是里面的一维数组</span><br><span class="line">j：表示一维数组中的索引，获取出来的就是真正的元素</span><br></pre></td></tr></table></figure>

<h3 id="二维数组的遍历"><a href="#二维数组的遍历" class="headerlink" title="二维数组的遍历"></a>二维数组的遍历</h3><p><strong>&#x2F;&#x2F;外循环：遍历二维数组，得到里面每一个一维数组</strong></p>
<p>for(int i&#x3D;0;<strong>i&lt;arr.length</strong>;i++){</p>
<p><strong>&#x2F;&#x2F;内循环：遍历一维数组，得到里面每一个元素</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     for（int j=0;j&lt;arr[i].length;j++）&#123;</span><br><span class="line">   system.out.println(arr[i] [j] + &quot; &quot; );</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维数组的内存图"><a href="#二维数组的内存图" class="headerlink" title="二维数组的内存图"></a>二维数组的内存图</h3><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**方法是程序中最小的执行单元**</span><br></pre></td></tr></table></figure>

<h3 id="方法的格式"><a href="#方法的格式" class="headerlink" title="方法的格式"></a>方法的格式</h3><p>把一些代码打包在一起，用到的时候就调用</p>
<h4 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a><strong>方法定义</strong></h4><p>把一些代码打包在一起，该过程称为方法定义</p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a><strong>方法调用</strong></h4><p>方法定义后不是直接运行的，需要手动调用才能执行，该过程称为方法调用</p>
<h5 id="最简单的方法定义"><a href="#最简单的方法定义" class="headerlink" title="最简单的方法定义"></a><strong>最简单的方法定义</strong></h5><p><strong>格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public  static void 方法名（）&#123;</span><br><span class="line">方法体（就是打包起来的代码）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法名（）；</span><br></pre></td></tr></table></figure>

<h5 id="带参数的方法定义"><a href="#带参数的方法定义" class="headerlink" title="带参数的方法定义"></a>带参数的方法定义</h5><p><strong>格式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public  static void 方法名（参数1，参数2，参数3…）&#123;……&#125;</span><br><span class="line">范例：public  static void 方法名（int number1，int number2，int number3…）&#123;……&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     方法名（参数1，参数2，参数3…）；</span><br><span class="line">范例：getSum(10，20，30)；</span><br></pre></td></tr></table></figure>

<p><em><strong>注意</strong></em>：方法调用时，参数的<strong>数量与类型</strong>必须与方法定义中小括号里面的变量<strong>一一对应</strong>，否则程序将报错</p>
<h5 id="带返回值的方法定义"><a href="#带返回值的方法定义" class="headerlink" title="带返回值的方法定义"></a>带返回值的方法定义</h5><p><strong>格式：</strong></p>
<p>public  static  返回值类型  方法名（参数）{</p>
<p>   方法体；</p>
<p>   return 返回值；</p>
<p>}</p>
<p><strong>调用方式：</strong></p>
<p>1.直接调用：方法名（实参）；</p>
<p>2.赋值调用：整数类型 变量名 &#x3D;方法名（实参）；</p>
<p>3.输出调用：System.out.println(方法名（实参）)；</p>
<h3 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在同一个类中，定义了多个同名的方法，这些同名的方法具有同种的功能</span><br><span class="line">每个方法具有不同的参数类型或参数个数，这些同名的方法，就构成了重载关系</span><br><span class="line">**简单记：同一类中，方法名相同，参数不同的方法。与返回值无关**</span><br><span class="line">参数不同：个数不同、类型不同、顺序不同</span><br></pre></td></tr></table></figure>

<h3 id="方法的内存"><a href="#方法的内存" class="headerlink" title="方法的内存"></a>方法的内存</h3><p>1.方法调用的基本内存原理：先进后出</p>
<p>2.方法传递<strong>基本数据类型的内存原理</strong></p>
<p>基本数据类型：数据值是存储在自己的空间中</p>
<p><strong>特点：赋值给其他变量，也是赋的真实的值</strong></p>
<p>▲<strong>传递基本数据类型时，传递的是真实值，形参的改变，不影响实际参数的值</strong></p>
<p>3.方法传递<strong>引用数据类型的内存原理</strong></p>
<p>引用数据类型：数值是存储在其他空间中，自己空间中存储的是地址值</p>
<p><strong>特点：赋值给其他变量时，赋的是地址值</strong></p>
<p>▲<strong>传递引用数据类型时，传递的是地址值，形参的改变，影响实际参数的值</strong></p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="设计对象并使用"><a href="#设计对象并使用" class="headerlink" title="设计对象并使用"></a>设计对象并使用</h2><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>类：是对象共同特征的描述（设计图）</p>
<p>对象：是真实存在的具体东西，具体实例</p>
<p><strong>如何定义类：</strong></p>
<p>public calss 类名{                                                              public calss   Phone{</p>
<p><strong>1.成员变量（代表属性，一般是名词）</strong>                  &#x2F;&#x2F;属性               String brand;</p>
<p>**2.成员方法（代表行为，一般是动词） **                                          double price;</p>
<p>3.构造器                                                                    &#x2F;&#x2F;行为      Public void call（）{  }             </p>
<p>4.代码块                                                                                     Public void playGame（）{  }     </p>
<p>5.内部类                                                                               }</p>
<p>}</p>
<p><strong>获得类的对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类名  对象名 =new 类名（）；</span><br><span class="line">Phone p =new Phone；</span><br></pre></td></tr></table></figure>

<p><strong>使用对象</strong></p>
<p>访问属性：对象名.成员变量</p>
<p>访问行为：对象名.方法名（……）</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a><strong>static</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.静态属性（类属性）与实例属性（对象属性）</span><br><span class="line">静态属性，只有一份，可以通过 类名.属性名/对象.属性名 来赋值和访问</span><br><span class="line">实例属性，每个对象都有一份，只能通过 对象.属性名  来赋值和访问</span><br><span class="line">2.静态方法与实例方法（对象方法）</span><br><span class="line">静态方法只能调用静态方法，不能调用实例方法或实例属性</span><br><span class="line">实例方法可以调用静态方法和实例方法，也可以访问静态属性和实例属性</span><br></pre></td></tr></table></figure>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.abstract只能修饰类和方法</span><br><span class="line">用abstract关键词来修饰一个类时，这个类就叫抽象类</span><br><span class="line">用abstract关键词来修饰一个方法时，这个类就叫抽象方法  //抽象方法没有方法体，它不可能被用到</span><br><span class="line">2.抽象类注意事项</span><br><span class="line">抽象类可以有任意成员，可以被继承，可以没有抽象方法</span><br><span class="line">抽象类不能被实例化                              //不能new创建对象</span><br><span class="line">有了抽象方法，则这个类必须声明为abstract</span><br><span class="line">继承了抽象类，则必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类</span><br><span class="line">抽象方法不能用private、final和static来修饰</span><br></pre></td></tr></table></figure>

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>如何正确设计对象的属性和方法</p>
<p><em><strong>对象代表什么，就得封装对应的数据，并提供数据对应的行为</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private关键词</span><br><span class="line">1.是一个权限修饰符</span><br><span class="line">2.可以修饰成员（成员变量和成员方法）       针对每一个私有化的成员变量，都要提供get和set方法，方法用public修饰</span><br><span class="line">3.被private修饰的成员只能在本类调用                       set方法：给成员变量赋值</span><br><span class="line">                                                     get方法：对外提供成员变量的值</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">就近原则</span><br><span class="line">//谁离我近，我就用谁</span><br><span class="line">System.out.println(**age**);                            //局部变量</span><br><span class="line">System.out.println(**this.age**);                       //成员变量</span><br><span class="line">this的作用：可以区分成员变量和局部变量</span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>提高代码复用性，继承是多态的前提</p>
<p>继承的注意事项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.继承的语法</span><br><span class="line">  class 子类  extends 父类&#123;&#125;    //父类中存放重复的代码</span><br><span class="line">2.当多个类存在相同的属性和方法时，可以从这些类中抽出父类，在父类中定义这些相同的方法和属性，所有的子类不需要重新定义这些方法和属性，只需要通过extends来声明继承父类即可</span><br><span class="line">3.子类自动拥有父类所有的属性和方法（受访问修饰符影响）</span><br></pre></td></tr></table></figure>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数定义成父类类型，就可以传任意子类类型进去</span><br></pre></td></tr></table></figure>

<p>向上转型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.语法：父类类型 引用名=new 子类类型（）</span><br><span class="line">2.父类引用指向子类对象</span><br><span class="line">3.可以调用父类中的所有成员（受访问修饰符限制）</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.多态的前提：两个对象（类）存在继承关系</span><br><span class="line">2.属性的值看编译类型（表面写出来的类型）</span><br><span class="line">3.只要编译能通过，方法都是看运行类型（实际类型），属性看编译类型</span><br><span class="line">4.instanceof 比较操作符，用于判断对象的运行类型是否为xx类型或xx类型的子类</span><br><span class="line">// Person person1=new Student()；        System.out.println(person1 instanceof Student);    //true</span><br><span class="line">   Person person2=new Teacher()；        System.out.println(person1 instanceof Teacher);    //false</span><br><span class="line">   Person person3=new Person()；         System.out.println(person1 instanceof Person);     //true</span><br></pre></td></tr></table></figure>

<p><strong>多态数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数组定义类型为父类类型，里面保存的实际元素类型为子类类型</span><br><span class="line">Person [] p =new Person[]&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态绑定机制</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">main方法中</span><br><span class="line">A a=new B（）；</span><br><span class="line">system.out.println(a.sum());</span><br><span class="line">system.out.println(a.sum1());</span><br><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">public int i =10;</span><br><span class="line">public int sum() &#123;return getI()+20;&#125;</span><br><span class="line">public int sum()1 &#123;return i+10;&#125;</span><br><span class="line">public int getI() &#123;return i;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A&#123;</span><br><span class="line">public int i =20;</span><br><span class="line">public int sum() &#123;return i+20;&#125;</span><br><span class="line">public int sum()1 &#123;return i+10;&#125;</span><br><span class="line">public int getI() &#123;return i;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//1.当调用对象方法时，该方法会和对象的内存地址/运行类型绑定            只要是遇到方法全部是从子类开始往上找</span><br><span class="line">2.当调用对象属性时，没有动态绑定机制，就近原则</span><br></pre></td></tr></table></figure>

<h2 id="构造器（构造方法）"><a href="#构造器（构造方法）" class="headerlink" title="构造器（构造方法）"></a>构造器（构造方法）</h2><p>构造方法也叫构造器、构造函数</p>
<p>作用：在创建对象的时候给成员变量进行赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">public class Student&#123;</span><br><span class="line">修饰符  类名（参数）&#123;</span><br><span class="line">       方法体；</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">1.方法名和类名相同，大小写也要一致</span><br><span class="line">2.没有返回值类型，连void都没有</span><br><span class="line">3.没有具体的返回值（不能由return带回结果数据）</span><br></pre></td></tr></table></figure>

<p><strong>空参构造</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Student（）&#123;……&#125;</span><br></pre></td></tr></table></figure>

<p><strong>带参构造</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Student（String name，int age）&#123;……&#125;           **//在调用的时候可以直接给成员变量赋值**</span><br></pre></td></tr></table></figure>

<h3 id="父类构造器"><a href="#父类构造器" class="headerlink" title="父类构造器"></a>父类构造器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器</span><br><span class="line">2.如果父类没有无参构造器，则需在子类构造器中用super去指定使用父类的哪个构造器</span><br><span class="line">  super（参数列表）；</span><br><span class="line">  super（）和this（）都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</span><br><span class="line">3.父类构造器的调用不限与直接父类，一致追溯到Object类（顶级父类）</span><br></pre></td></tr></table></figure>

<h1 id="标准的JavaBean类"><a href="#标准的JavaBean类" class="headerlink" title="标准的JavaBean类"></a>标准的JavaBean类</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.类名需要见名知意</span><br><span class="line">2.成员变量使用private修饰</span><br><span class="line">3.提供至少两个构造方法（无参构造方法/带全部参数的构造方法）</span><br><span class="line">4.成员方法</span><br><span class="line">提供每一个成员变量对应的setxxx（）/getxxx（）</span><br><span class="line">如果还有其他行为，也需要写上</span><br></pre></td></tr></table></figure>

<h1 id="API-字符串"><a href="#API-字符串" class="headerlink" title="API&amp;字符串"></a>API&amp;字符串</h1><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>API：应用程序编程接口</p>
<p>目前是jdk中提供的各种功能的Java类</p>
<h3 id="字符串学习内容"><a href="#字符串学习内容" class="headerlink" title="字符串学习内容"></a>字符串学习内容</h3><h4 id="string概述"><a href="#string概述" class="headerlink" title="string概述"></a><strong>string概述</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符串的内容是不会改变的，它的对象在创建后不能被更改</span><br><span class="line">字符串拼接产生一个新的字符串</span><br></pre></td></tr></table></figure>

<p><strong>创建string对象的两种方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.直接赋值</span><br><span class="line">2.new</span><br><span class="line">构造方法</span><br><span class="line">public string （）                     创建空白字符串，不包含任何内容</span><br><span class="line">public string （char[]  chs）          根据字符数组，创建字符串对象</span><br><span class="line">public string （byte[]  chs）          根据字节数组，创建字符串对象</span><br></pre></td></tr></table></figure>

<p><strong>字符串的比较</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string  s1=new  string（“abc”）；</span><br><span class="line">string  s2=new  string（“abc”）；</span><br><span class="line">system.out.println( s1 == s2 ) ;  //false  引用数据类型比较的是地址值</span><br><span class="line"></span><br><span class="line">string  s1= “abc”；</span><br><span class="line">string  s2=new  string（“abc”）；  //false </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Boolean equals方法（要比较的字符串）        完全一样结果才是true，否则为false</span><br><span class="line">Boolean equalsignorecase（要比较的字符串） 忽略大小写的比较</span><br></pre></td></tr></table></figure>

<h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equals是Object类中的方法，只能判断引用类型</span><br><span class="line">默认判断的是地址值是否相等</span><br><span class="line">子类一般会重写equals方法，用于判断内容是否相等，比如integer、string</span><br></pre></td></tr></table></figure>

<h4 id="stringbuilder"><a href="#stringbuilder" class="headerlink" title="stringbuilder"></a>stringbuilder</h4><p>stringbuilder可以看成是一个容器，创建之后里面的内容是可变的</p>
<p>作用：提高字符串的操作效率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法名                                             说明</span><br><span class="line">public StringBuilder append（任意类型）         添加数据，并返回对象本身</span><br><span class="line">public StringBuilder reverse（）               反转容器中的内容</span><br><span class="line">public String toString（）                     通过tostring（）就可以把StringBuilder转换为string</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">实例：</span><br><span class="line">StringBuilder sb=new StringBuilder(&quot;abc&quot;);</span><br><span class="line">sb.append(1);</span><br><span class="line">sb.append(23);</span><br><span class="line">sb.append(true);</span><br><span class="line">system.out.println(sb);    //abc123true</span><br></pre></td></tr></table></figure>

<h4 id="tostring"><a href="#tostring" class="headerlink" title="tostring"></a>tostring</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认返回：全类名+@+哈希值的十六进制</span><br><span class="line">子类往往重写tostring方法，用于返回对象的属性信息</span><br><span class="line">当直接输出一个对象时，tostring方法会被默认的调用</span><br></pre></td></tr></table></figure>

<h4 id="stringjoiner"><a href="#stringjoiner" class="headerlink" title="stringjoiner"></a>stringjoiner</h4><p>作用：提高字符串的操作效率，而且代码编写特别简洁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造方法</span><br><span class="line">方法名                                             说明</span><br><span class="line">public stringjoiner（间隔符号）                 创建一个stringjoiner对象，指定拼接时的间隔符号</span><br><span class="line">public stringjoiner（间隔符号，开始符号，结束符号）创建一个stringjoiner对象，指定拼接时的间隔符号、开始符号、结束符号</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">成员方法</span><br><span class="line">方法名                                             说明</span><br><span class="line">public stringjoiner add（添加的内容）           添加数据（只能是字符串），并返回对象本身</span><br><span class="line">public String toString（）                    返回一个字符串（该字符串就是拼接之后的结果）</span><br></pre></td></tr></table></figure>

<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>基本语法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface  接口名&#123;</span><br><span class="line">  //属性</span><br><span class="line">  //方法</span><br><span class="line">&#125;</span><br><span class="line">class 类名 implements 接口名&#123;</span><br><span class="line">  必须实现接口的所有抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.接口不能被实例化</span><br><span class="line">2.接口的修饰符只能是public和默认</span><br><span class="line">3.一个接口不能继承其他的类，但是可以继承多个别的接口</span><br></pre></td></tr></table></figure>


		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Java语言</li>
        <li><strong>Author:</strong> The Redefine Team</li>
        <li><strong>Created at
                :</strong> 2025-03-18 20:48:18</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-03-18 20:49:23
            </li>
        
        <li>
            <strong>Link:</strong> https://redefine.ohevan.com/2025/03/18/Java语言/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/03/12/hello-world/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Hello World</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://example.example.com',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          reaction: false,
          requiredMeta: ['nick', 'mail'],
          emoji: [],
          
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Java语言</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5"><span class="nav-text">键盘录入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">三元运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">运算符优先级</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-text">流程控制语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-text">顺序结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="nav-text">分支结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-text">循环结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">数组的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">数组的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%9C%B0%E5%9D%80%E5%80%BC"><span class="nav-text">数组的地址值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="nav-text">数组元素访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="nav-text">数组遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-text">数组的内存图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-text">二维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">二维数组的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="nav-text">二维数组的元素访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">二维数组的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="nav-text">二维数组的内存图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-text">方法的格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-text">方法的重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%86%85%E5%AD%98"><span class="nav-text">方法的内存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E5%AF%B9%E8%B1%A1%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="nav-text">设计对象并使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-text">类和对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">抽象类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-text">封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-text">继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-text">多态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-text">构造器（构造方法）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">父类构造器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E7%9A%84JavaBean%E7%B1%BB"><span class="nav-text">标准的JavaBean类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#API-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">API&amp;字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#API"><span class="nav-text">API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%A6%E4%B9%A0%E5%86%85%E5%AE%B9"><span class="nav-text">字符串学习内容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text">接口</span></a></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">The Redefine Team</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        2 posts in total
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>





    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>








    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





	
</body>

</html>